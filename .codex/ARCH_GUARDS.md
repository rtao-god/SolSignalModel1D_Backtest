# Конвенции и инварианты (архитектурные «ограждения»)

## Корректность сборки и миграций
- Не вводить compile-only «shim»/прокладки, которые меняют runtime-семантику.
- Не оставлять устаревшие свойства/контракты «в живом использовании» ради компиляции:
  вместо этого мигрировать call-sites на канон.
- Не «чинить» компиляцию, двигая каноничный контракт под текущие call-sites:
  сначала найти владельца контракта, затем привести call-sites к нему.

## Время и семантические типы (не смешивать)
- Если функция ожидает `EntryUtc`, нельзя передавать `NyTradingEntryUtc` без явного преобразования/адаптера.
- Day-key ≠ instant:
  - day-key — это ключ суток (00:00Z), а не точка времени;
  - сравнение/сортировка day-key допустимы только в их семантике «день-ключ».
- Если встречаются obsolete `DayKeyUtc`:
  - заменить на **явные** `EntryDayKeyUtc` / `ExitDayKeyUtc` (или эквиваленты) в зависимости от смысла.
- Любые публичные API, принимающие `DateTime`, должны явно требовать `DateTimeKind.Utc` (или принимать семантический тип).

## Каузальность
- Любой `Try*`, возвращающий `false`, — это доменное «не подходит / не eligible».
- Любой некорректный ввод (default, неверный `DateTimeKind`, null tz, null коллекции) — баг вызывающей стороны ⇒ `throw`.
- В каузальных компонентах запрещено строить признаки/лейблы с доступом к будущему.
- Нельзя прокидывать omniscient-структуры (например, `BacktestRecord`/forward outcomes) внутрь causal-строителей признаков/лейблов.

## Семантика NY-окон
- Канон: `NyWindowing` — единственный источник истины по:
  - NY morning (с учётом DST),
  - weekend eligibility по NY локальному времени,
  - baseline-exit,
  - производным day-key.
- baseline-exit определён как: **следующее NY-утро минус 2 минуты**.
- Friday entry: baseline-exit переносится на **понедельник** (NY-логика).

## Семантика spлитов train/oos
- Сплит делается не по entry-day, а по **day-key baseline-exit**.
- Excluded существует (например: weekend по NY / невалидный вход для торгового дня / невозможность окна).
- «Мягкий сплит» нужен там, где excluded важно учитывать (диагностика, покрытие, data quality).
- «Жёсткий сплит» нужен на границах, где excluded недопустим (обучение/контракт training-only):
  - при excluded — fail-fast,
  - сообщение должно включать `entryUtc`, по возможности NY-local stamp, baseline-exit и `tag` вызывающей стороны.

## Семантика baseline-exit vs TrainUntil
- `TrainUntilUtc` сравнивается с `BaselineExitUtc`, а не с `EntryUtc`.
- Даже если `EntryUtc < TrainUntilUtc`, baseline-exit может быть позже (например, пятница → понедельник).
- На границах TrainUntil использовать один канон вычисления порога (например, `ExitDayKeyUtc.FromUtcMomentOrThrow(trainUntilUtc)` или эквивалент владельца).
- Ошибки вида `baselineExit <= trainUntil` логировать/включать в исключение:
  - `entryUtc`, NY-local stamp, `baselineExitUtc`, `trainUntilUtc`, `tag`.

## Данные свечей и порядок рядов (инварианты качества данных)
- После init серии должны быть строго возрастающими по времени и строго уникальными по ключу:
  - любые дубли/пересечения по `OpenTimeUtc` — фатальная проблема данных (fail-fast), не «лечить сортировкой».
- 1m (если используются weekday + weekend источники):
  - weekend-файл не должен пересекаться по минутам с основным 1m;
  - merge должен быть строго возрастающим.
- Нельзя добавлять `OrderBy`/пересортировку свечей «на всякий случай» в середине пайплайна:
  это маскирует коррупцию данных и ломает диагностику.

## Логирование и ошибки
- Исключения должны давать достаточно контекста для отладки без воспроизведения:
  - `entryUtc`, day-key, `tag`, counts, диапазоны и т.п.
- Не глотать исключения:
  - допускается оборачивать в `InvalidOperationException`/`ArgumentException` с контекстом и `innerException`.

## Гигиена диффа
- Предпочитать локальные, явные изменения в call-sites.
- Не форматировать/переименовывать нерелевантный код.
