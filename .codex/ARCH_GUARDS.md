# Конвенции и инварианты (архитектурные «ограждения»)

## Корректность сборки и миграций
- Не вводить compile-only «shim»/прокладки, которые меняют runtime-семантику.
- Не оставлять устаревшие свойства/контракты «в живом использовании» ради компиляции:
  вместо этого мигрировать call-sites на канон.

## Время и семантические типы (не смешивать)
- Если функция ожидает `EntryUtc`, нельзя передавать `NyTradingEntryUtc` без явного преобразования/адаптера.
- Day-key ≠ instant:
  - day-key — это ключ суток (00:00Z), а не точка времени;
  - сравнение/соритровка day-key допустимы только в их семантике «день-ключ».
- Если встречаются obsolete `DayKeyUtc`:
  - заменить на **явные** `EntryDayKeyUtc` / `ExitDayKeyUtc` в зависимости от смысла.

## Каузальность
- Любой `Try*`, возвращающий `false`, — это доменное «не подходит / не eligible».
- Любой некорректный ввод (default, неверный DateTimeKind, null tz, null коллекции) — баг вызывающей стороны ⇒ `throw`.
- В каузальных компонентах запрещено строить признаки/лейблы с доступом к будущему.

## Семантика сплита train/oos
- Сплит делается не по entry-day, а по day-key базового окна (baseline-exit).
- Excluded существует (например: weekend по NY / невалидный вход для торгового дня / невозможность окна).
- «Мягкий сплит» нужен там, где excluded важно учитывать (диагностика, покрытие, data quality).
- «Жёсткий сплит» нужен на границах, где excluded недопустим (обучение/контракт training-only):
  - при excluded — fail-fast,
  - сообщение должно включать `entryUtc`, по возможности NY-local stamp, и `tag` вызывающей стороны.

## Логирование и ошибки
- Исключения должны давать достаточно контекста для отладки без воспроизведения:
  - `entryUtc`, day-key, `tag`, counts, диапазоны и т.п.
- Не глотать исключения:
  - допускается оборачивать в `InvalidOperationException`/`ArgumentException` с контекстом и `innerException`.

## Гигиена диффа
- Предпочитать локальные, явные изменения в call-sites.
- Не форматировать/переименовывать нерелевантный код.

## Семантика baseline-exit vs TrainUntil

- TrainUntilUtc сравнивается с BaselineExitUtc, а не с EntryUtc.

- Даже если EntryUtc < TrainUntil, baseline-exit может быть позже (например, пятница → понедельник).

- На границах TrainUntilUtc использовать TrainUntilUtc.ExclusiveEnd как UTC-порог.

- Ошибки типа baselineExit <= trainUntilUtc логировать с entryUtc, NY-local stamp, baseline-exit и tag.